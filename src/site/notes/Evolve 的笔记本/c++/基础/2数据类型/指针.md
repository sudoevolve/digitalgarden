---
{"dg-publish":true,"permalink":"/Evolve 的笔记本/c++/基础/2数据类型/指针/","created":"2025-01-17T15:54:32.171+08:00"}
---

### **1. 指针基础**

#### **定义指针**

指针是存储地址的变量。它保存的是另一个变量的内存地址，而不是变量的值。

```cpp
int x = 10;      // x 是一个整型变量
int* ptr = &x;   // ptr 是一个指向整型变量 x 的指针，保存了 x 的内存地址
```

#### **指针声明与初始化**

指针声明的基本语法是：

```cpp
type* pointerName;
```

- `type` 表示指针指向的变量类型。
- `pointerName` 是指针变量的名称。

**初始化指针**： 指针可以通过获取变量的地址来初始化，地址使用取地址符 `&`。

```cpp
int num = 5;
int* ptr = &num; // ptr 指向 num 变量的内存地址
```

#### **解引用**

解引用符 `*` 用于访问指针所指向的变量的值。

```cpp
std::cout << *ptr;  // 输出 num 的值，即 5
```

---

### **2. 指针与数组**

在C++中，数组的名字本质上就是指向数组第一个元素的指针。你可以通过指针来操作数组元素。

#### **指针访问数组**

```cpp
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr;  // ptr 指向数组的第一个元素

std::cout << *ptr;       // 输出 1
std::cout << *(ptr + 1);  // 输出 2
```

#### **数组指针与指针数组**

- **数组指针**：指向数组的指针，类型是 `type (*)[size]`，例如 `int (*arrPtr)[5]`。
- **指针数组**：数组中的每个元素都是指针，例如 `int* arr[5]`。

#### **示例：**

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* arrPtr[5];  // 声明指针数组

for (int i = 0; i < 5; ++i) {
    arrPtr[i] = &arr[i];  // 数组元素是指向 arr 中每个元素的指针
    std::cout << *arrPtr[i] << " "; // 输出 10 20 30 40 50
}
```

---

### **3. 指针与结构体**

指针不仅可以指向基本类型的变量，还可以指向结构体或类。指向结构体的指针可以用来访问结构体成员。

#### **示例：**

```cpp
struct Person {
    std::string name;
    int age;
};

Person p1 = {"Alice", 30};
Person* ptr = &p1;  // ptr 指向结构体 p1 的地址

std::cout << ptr->name;  // 输出 "Alice"
std::cout << ptr->age;   // 输出 30
```

- **结构体指针的成员访问**：通过指针访问结构体的成员时，使用 `->` 操作符，而不是 `.` 操作符。

---

### **4. 动态内存分配**

C++ 提供了 `new` 和 `delete` 操作符来进行动态内存管理。`new` 用于分配内存，`delete` 用于释放内存。

#### **使用 `new` 动态分配内存**

```cpp
int* ptr = new int;  // 分配一个 int 类型的内存
*ptr = 10;           // 给分配的内存赋值
std::cout << *ptr;   // 输出 10
```

#### **释放内存**

```cpp
delete ptr;  // 释放动态分配的内存
```

- 注意：使用 `new` 动态分配内存后，一定要用 `delete` 释放，否则会导致内存泄漏。

#### **数组的动态内存分配**

```cpp
int* arr = new int[5];  // 动态分配一个包含 5 个 int 元素的数组
arr[0] = 1;
arr[1] = 2;
std::cout << arr[0];  // 输出 1

delete[] arr;  // 释放动态分配的数组
```

---

### **5. 指向指针的指针**

指针可以指向另一个指针，这样的指针称为**指向指针的指针**（pointer to pointer）。

```cpp
int x = 10;
int* ptr1 = &x;      // ptr1 指向 x 的地址
int** ptr2 = &ptr1;  // ptr2 指向 ptr1 的地址

std::cout << **ptr2;  // 输出 10
```

#### **多级指针的使用**

可以使用多个 `*` 访问多级指针所指向的值，每增加一层 `*` 就表示向前解引用一步。

---

### **6. 函数指针**

函数指针是指向函数的指针，可以用来间接调用函数。

#### **定义和使用函数指针**

```cpp
#include <iostream>
using namespace std;

// 定义一个函数
void printMessage() {
    cout << "Hello, World!" << endl;
}

int main() {
    // 声明一个函数指针
    void (*funcPtr)() = &printMessage;

    // 使用函数指针调用函数
    funcPtr();  // 输出 "Hello, World!"
}
```

- **函数指针的声明**：`返回类型 (*函数指针名)(参数类型)`。
- **调用函数**：通过函数指针 `funcPtr()` 来调用对应的函数。

---

### **7. 常见错误与指针管理**

#### **空指针解引用**

空指针（`nullptr`）解引用会导致程序崩溃。

```cpp
int* ptr = nullptr;
std::cout << *ptr;  // 错误：空指针解引用
```

#### **野指针**

指针指向的内存已经被释放，但指针仍然存在，这种指针称为**野指针**，会导致程序不稳定。

```cpp
int* ptr = new int(10);
delete ptr;  // 释放内存
std::cout << *ptr;  // 错误：访问已删除的内存
```

#### **指针越界**

访问指针指向的数组或内存超出有效范围会导致错误。

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
std::cout << *(ptr + 10);  // 错误：越界访问
```

---

### **8. 指针与常量**

指针与常量结合的几种情况：

1. **常量指针**：指针的值（即内存地址）不可改变，但可以通过它改变所指向的内容。
    
    ```cpp
    int x = 10;
    int* const ptr = &x;  // 常量指针
    *ptr = 20;            // 可以修改所指向的值
    // ptr = &y;          // 错误：不能修改指针本身
    ```
    
2. **指向常量的指针**：指针所指向的值不能修改，但指针本身可以修改。
    
    ```cpp
    const int x = 10;
    const int* ptr = &x;  // 指向常量的指针
    // *ptr = 20;         // 错误：不能修改指向的值
    ptr = &y;             // 可以修改指针
    ```
    
3. **常量指针指向常量**：既不能修改指针本身，也不能修改指针指向的值。
    
    ```cpp
    const int x = 10;
    const int* const ptr = &x;  // 常量指针指向常量
    ```
    

---
## 案例：


### **案例一：交换两个整数的值（使用指针）**

#### **问题描述**：

你需要编写一个函数，用指针交换两个整数的值。

#### **分析**：

指针可以通过传递变量的地址来实现修改原变量的值。因此，可以传递指向整数的指针，在函数内部修改这些指针所指向的值。

#### **代码实现**：

```cpp
#include <iostream>
using namespace std;

// 交换函数
void swap(int* a, int* b) {
    int temp = *a;  // 通过解引用获取 a 指向的值
    *a = *b;        // 修改 a 指向的值
    *b = temp;      // 修改 b 指向的值
}

int main() {
    int x = 5;
    int y = 10;

    cout << "交换前: x = " << x << ", y = " << y << endl;

    // 传递指针到交换函数
    swap(&x, &y);

    cout << "交换后: x = " << x << ", y = " << y << endl;

    return 0;
}
```

#### **解释**：

1. **swap函数**：函数 `swap` 接受两个指针 `a` 和 `b`，并通过解引用操作符 `*` 获取指针所指向的值，然后交换这两个值。
2. **传递指针**：在 `main` 函数中，我们通过传递 `&x` 和 `&y`（即 `x` 和 `y` 的地址）来实现对这两个变量值的交换。
3. **输出结果**：
    
    ```text
    交换前: x = 5, y = 10
    交换后: x = 10, y = 5
    ```
    

这个案例展示了如何通过指针在函数内部修改变量的值，从而达到交换两个变量的目的。

---

### **案例二：动态数组的内存管理（使用指针）**

#### **问题描述**：

创建一个动态数组，并使用指针管理数组的内存。实现一个函数，能够动态地为数组分配内存，初始化数组内容，然后释放内存。

#### **分析**：

我们可以使用 `new` 来动态分配内存，使用指针来操作这些动态分配的内存。动态内存分配的优势是能够在运行时决定数组的大小，且不受编译时固定大小的限制。

#### **代码实现**：

```cpp
#include <iostream>
using namespace std;

void createAndDisplayArray(int size) {
    // 使用 new 动态分配内存
    int* arr = new int[size];  

    // 初始化数组内容
    for (int i = 0; i < size; ++i) {
        arr[i] = i + 1;
    }

    // 显示数组内容
    for (int i = 0; i < size; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    // 使用 delete 释放内存
    delete[] arr;
}

int main() {
    int size;
    cout << "请输入数组大小：";
    cin >> size;

    // 调用函数，传递数组大小
    createAndDisplayArray(size);

    return 0;
}
```

#### **解释**：

1. **动态内存分配**：`int* arr = new int[size];` 使用 `new` 动态分配一个大小为 `size` 的整型数组。
2. **初始化与访问数组**：通过指针 `arr` 来访问数组元素，例如 `arr[i] = i + 1;`。
3. **释放内存**：当不再需要数组时，使用 `delete[] arr;` 释放动态分配的内存，避免内存泄漏。

#### **输出结果**：

假设输入数组大小为 5，输出会是：

```text
请输入数组大小：5
1 2 3 4 5
```

#### **关键点**：

- 动态数组的大小可以在运行时确定，这是与静态数组（编译时确定大小）不同的地方。
- 使用 `new` 和 `delete` 动态分配和释放内存，避免内存泄漏。

---
